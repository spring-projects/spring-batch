[[configuringJobOperator]]
= Configuring a JobOperator

The most basic implementation of the `JobOperator` interface is the `TaskExecutorJobOperator`.
It requires only one dependency: a `JobRepository`. All other dependencies like `JobRegistry`,
`MeterRegistry`, `TransactionManager`, etc are optional. Spring Batch provides a factory bean
to simplify the configuration of this operator: `JobOperatorFactoryBean`. This factory bean
creates a transactional proxy around the `TaskExecutorJobOperator` to ensure that all its public methods
are executed within a transaction.

[tabs]
====
Java::
+
The following example shows how to configure a `TaskExecutorJobOperator` in Java:
+
.Java Configuration
[source, java]
----
...
@Bean
public JobOperatorFactoryBean jobOperator(JobRepository jobRepository) {
	JobOperatorFactoryBean jobOperatorFactoryBean = new JobOperatorFactoryBean();
	jobOperatorFactoryBean.setJobRepository(jobRepository);
	return jobOperatorFactoryBean;
}
...
----

XML::
+
The following example shows how to configure a `TaskExecutorJobOperator` in XML:
+
.XML Configuration
[source, xml]
----
<bean id="jobOperator" class="org.springframework.batch.core.launch.support.JobOperatorFactoryBean">
    <property name="jobRepository" ref="jobRepository" />
</bean>
----

====


Once a xref:domain.adoc[JobExecution] is obtained, it is passed to the
execute method of `Job`, ultimately returning the `JobExecution` to the caller, as
the following image shows:

.Job Launcher Sequence
image::job-launcher-sequence-sync.png[Job Launcher Sequence, scaledwidth="50%"]

The sequence is straightforward and works well when launched from a scheduler. However,
issues arise when trying to launch from an HTTP request. In this scenario, the launching
needs to be done asynchronously so that the `TaskExecutorJobOperator` returns immediately to its
caller. This is because it is not good practice to keep an HTTP request open for the
amount of time needed by long running processes (such as batch jobs). The following image shows
an example sequence:

.Asynchronous Job Launcher Sequence
image::job-launcher-sequence-async.png[Async Job Launcher Sequence, scaledwidth="50%"]

You can configure the `TaskExecutorJobOperator` to allow for this scenario by configuring a
`TaskExecutor`.

[tabs]
====
Java::
+
The following Java example configures a `TaskExecutorJobOperator` to return immediately:
+
.Java Configuration
[source, java]
----
@Bean
public JobOperatorFactoryBean jobOperator(JobRepository jobRepository) {
	JobOperatorFactoryBean jobOperatorFactoryBean = new JobOperatorFactoryBean();
	jobOperatorFactoryBean.setJobRepository(jobRepository);
	jobOperatorFactoryBean.setTaskExecutor(new SimpleAsyncTaskExecutor());
	return jobOperatorFactoryBean;
}
----

XML::
+
The following XML example configures a `TaskExecutorJobOperator` to return immediately:
+
.XML Configuration
[source, xml]
----
<bean id="jobOperator" class="org.springframework.batch.core.launch.support.JobOperatorFactoryBean">
    <property name="jobRepository" ref="jobRepository" />
    <property name="taskExecutor">
        <bean class="org.springframework.core.task.SimpleAsyncTaskExecutor" />
    </property>
</bean>
----

====

You can use any implementation of the Spring `TaskExecutor`
interface to control how jobs are asynchronously
executed.

